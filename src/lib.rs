pub mod protos;
use std::{collections::HashMap, iter::Scan, ops::Range, path::Path};

use protobuf::{descriptor::FileDescriptorProto, plugin::code_generator_response::File};
use protos::py_package;

pub struct InitPyConfig {
    py_imports: Vec<String>,
}

pub fn load_python_import_file() -> Vec<String> {
    // This function will load the pu_package_imports.txt file and
    // bundle it's contents as part of the binary.
    let content = include_str!("py_package_imports.txt");
    content
        .lines()
        .map(String::from)
        .collect::<Vec<String>>()
}

pub fn generate_py_init_configs(
    file_descriptor: &FileDescriptorProto,
    opts: &Option<py_package::PyPackageOptions>,
    file_contents: Vec<String>,
) -> HashMap<String, InitPyConfig> {
    let mut configs: HashMap<String, InitPyConfig> = HashMap::new();
    opts.as_ref()
        .into_iter()
        .filter(|opt| opt.enable)
        .flat_map(|opt| build_init_file_paths(opt, file_descriptor))
        .for_each(|(opts, file_path)| {
            let path = Path::new(&file_path);
            let parent_dir = path.parent().unwrap_or_else(|| Path::new(""));
            let parent_dir_str = parent_dir.to_string_lossy().to_string();
            let init_py_config = configs
                .entry(parent_dir_str)
                .or_insert_with(|| InitPyConfig {
                    py_imports: vec!["# Generated by protoc-gen-py-pkg".to_string()],
                });
            log::info!("Enable top level: {}", opts.enable_top_level_imports);

            if opts.enable_top_level_imports && parent_dir.components().count() == 1 {
                init_py_config.py_imports = file_contents.clone();
            }
        });
    configs
}

fn build_init_file_paths<'a>(
    opts: &'a py_package::PyPackageOptions,
    file_descriptor: &FileDescriptorProto,
) -> impl Iterator<Item = (&'a py_package::PyPackageOptions, String)>

// Scan<
//     Range<usize>,
//     String,
//     impl FnMut(&mut String, usize) -> Option<(&'a py_package::PyPackageOptions, String)>,> 
{
    let components: Vec<_> = file_descriptor.name().split('/').collect();
    // Use scan to accumulate path components while yielding each one.
    (0..components.len() - 1).scan(String::new(), move |path_so_far, index| {
        // let root_component = components.first();
        let current_component = components[index];
        let path_dir = if path_so_far.is_empty() {
            Path::new(&current_component).to_path_buf()
        } else {
            Path::new(&path_so_far).join(current_component)
        };
        // Update the path_so_far with the current component
        *path_so_far = path_dir.to_string_lossy().to_string();
        let file_name = path_dir.join("__init__.py").to_string_lossy().to_string();
        Some((opts, file_name))
    })
}

pub fn generate_py_init_files(
    configs: HashMap<String, InitPyConfig>,
) -> impl Iterator<Item = File> {
    // Iterate over the configurations and create `File` objects for each.
    configs.into_iter().flat_map(|(path, config)| {
        let mut file = File::new();
        file.set_name(format!("{}/__init__.py", path));
        // Set the content of the file to the imports.
        file.set_content(config.py_imports.join("\n"));
        Some(file)
    })
}

#[cfg(test)]
mod tests {
    use protobuf::descriptor::FileDescriptorProto;

    use super::*;

    #[test]
    fn it_should_generate_py_init_configs() {
        let mut opts = py_package::PyPackageOptions::new();
        opts.enable = true;
        opts.enable_top_level_imports = true;
        opts.parent_package = String::from("foo");
        let mut file_descriptor = FileDescriptorProto::new();
        file_descriptor.set_name(String::from("example/v1/foo.proto"));
        let mut foo = protobuf::descriptor::DescriptorProto::new();
        foo.set_name(String::from("Foo"));
        file_descriptor.message_type.push(foo);
        let binding = Some(opts);
        let result = generate_py_init_configs(
            &file_descriptor,
            &binding,
            vec![
                "# Generated by protoc-gen-py-pkg".to_string(),
                "from foo.example.v1.foo_pb2 import Foo".to_string(),
            ],
        );
        assert_eq!(result.len(), 2);
        assert!(result.contains_key("example"));
        assert!(result.contains_key("example/v1"));
        if let Some(init_config) = result.get("example") {
            assert_eq!(init_config.py_imports.len(), 2);
            assert_eq!(
                init_config.py_imports[0],
                "# Generated by protoc-gen-py-pkg"
            );
            assert_eq!(
                init_config.py_imports[1],
                "from foo.example.v1.foo_pb2 import Foo"
            );
        }
        if let Some(init_config) = result.get("example/v1") {
            assert_eq!(init_config.py_imports.len(), 1);
            assert_eq!(
                init_config.py_imports[0],
                "# Generated by protoc-gen-py-pkg"
            );
        }
    }

    #[test]
    fn it_should_generate_py_init_configs_with_no_opts() {
        let opts: Option<py_package::PyPackageOptions> = None;
        let result = generate_py_init_configs(&FileDescriptorProto::new(), &opts, vec![]);
        assert!(result.is_empty());
    }

    #[test]
    fn it_should_generate_py_init_configs_with_no_global_imports() {
        let mut opts = py_package::PyPackageOptions::new();
        opts.enable = true;
        opts.enable_top_level_imports = false;
        let mut file_descriptor = FileDescriptorProto::new();
        file_descriptor.set_name(String::from("example/v1/foo.proto"));
        let mut foo = protobuf::descriptor::DescriptorProto::new();
        foo.set_name(String::from("Foo"));
        file_descriptor.message_type.push(foo);
        let binding = Some(opts);
        let result = generate_py_init_configs(
            &file_descriptor,
            &binding,
            vec![
                "# Generated by protoc-gen-py-pkg".to_string(),
                "from foo.example.v1.foo_pb2 import Foo".to_string(),
            ],
        );
        assert_eq!(result.len(), 2);
        assert!(result.contains_key("example"));
        assert!(result.contains_key("example/v1"));
        if let Some(init_config) = result.get("example") {
            assert_eq!(init_config.py_imports.len(), 1);
            assert_eq!(
                init_config.py_imports[0],
                "# Generated by protoc-gen-py-pkg"
            );
        }
        if let Some(init_config) = result.get("example/v1") {
            assert_eq!(init_config.py_imports.len(), 1);
            assert_eq!(
                init_config.py_imports[0],
                "# Generated by protoc-gen-py-pkg"
            );
        }
    }

    #[test]
    fn it_should_generate_py_init_files() {
        let mut configs = HashMap::new();
        let init_config = InitPyConfig {
            py_imports: vec!["# Generated by protoc-gen-py-pkg".to_string()],
        };
        configs.insert("example".to_string(), init_config);
        let result: Vec<_> = generate_py_init_files(configs).collect();
        assert_eq!(result.len(), 1);
        if let Some(file) = result.first() {
            assert_eq!(file.name(), "example/__init__.py");
            assert_eq!(file.content(), "# Generated by protoc-gen-py-pkg");
        }
    }
}
