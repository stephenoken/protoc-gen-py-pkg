pub mod protos;
use std::{collections::HashMap, path::Path};

use protobuf::{
    descriptor::FileDescriptorProto,
    plugin::{CodeGeneratorRequest, CodeGeneratorResponse, code_generator_response::File},
};
use protos::py_package;

const CODE_GENERATOR_RESPONSE_FEATURE_PROTO3_OPTIONAL: u64 = 1;
struct InitPyConfig {
    py_imports: Vec<String>,
}

struct PyPackageConfig<'a> {
    opts: Option<py_package::PyPackageOptions>,
    file_descriptor: &'a FileDescriptorProto,
}

fn load_python_import_file(opts: &Option<py_package::PyPackageOptions>) -> Vec<String> {
    // This function will load the pu_package_imports.txt file and
    // bundle it's contents as part of the binary.
    let mut content: String;
    if opts
        .as_ref()
        .map(|o| o.enable_versioned_imports)
        .unwrap_or(false) {
            content = include_str!("py_top_py_package_versioned_imports.py").to_string();
        } else {
            content = include_str!("py_package_imports.py").to_string();
        }
    content += "\n";
    content.lines().map(String::from).collect::<Vec<String>>()
}

fn create_py_init_configs(
    file_descriptor: &FileDescriptorProto,
    opts: &Option<py_package::PyPackageOptions>,
    file_contents: Vec<String>,
) -> HashMap<String, InitPyConfig> {
    let mut configs: HashMap<String, InitPyConfig> = HashMap::new();
    opts.as_ref()
        .into_iter()
        .filter(|opt| opt.enable)
        .flat_map(|opt| build_init_file_paths(opt, file_descriptor))
        .for_each(|(opts, file_path)| {
            let path = Path::new(&file_path);
            let parent_dir = match path.parent() {
                Some(dir) => dir,
                None => {
                    log::warn!("File path {} has no parent directory.", file_path);
                    return;
                }
            };
            let parent_dir_str = parent_dir.to_string_lossy().to_string();
            let init_py_config = configs
                .entry(parent_dir_str)
                .or_insert_with(|| InitPyConfig {
                    py_imports: vec!["# Generated by protoc-gen-py-pkg\n".to_string()],
                });
            log::info!("Enable top level: {}", opts.enable_top_level_imports);

            if opts.enable_top_level_imports && parent_dir.components().count() == 1 {
                init_py_config.py_imports = file_contents.clone();
            }
        });
    configs
}

fn build_init_file_paths<'a>(
    opts: &'a py_package::PyPackageOptions,
    file_descriptor: &FileDescriptorProto,
) -> impl Iterator<Item = (&'a py_package::PyPackageOptions, String)> {
    let components: Vec<_> = file_descriptor.name().split('/').collect();
    // Use scan to accumulate path components while yielding each one.
    (0..components.len() - 1).scan(String::new(), move |path_so_far, index| {
        // let root_component = components.first();
        let current_component = components[index];
        let path_dir = if path_so_far.is_empty() {
            Path::new(&current_component).to_path_buf()
        } else {
            Path::new(&path_so_far).join(current_component)
        };
        // Update the path_so_far with the current component
        *path_so_far = path_dir.to_string_lossy().to_string();
        let file_name = path_dir.join("__init__.py").to_string_lossy().to_string();
        Some((opts, file_name))
    })
}

fn generate_py_init_files(configs: HashMap<String, InitPyConfig>) -> impl Iterator<Item = File> {
    // Iterate over the configurations and create `File` objects for each.
    configs.into_iter().flat_map(|(path, config)| {
        let mut file = File::new();
        let file_name = format!("{}/__init__.py", path);
        let content = config.py_imports.join("\n");
        file.set_name(file_name);
        // Set the content of the file to the imports.
        file.set_content(content);
        Some(file)
    })
}

fn extract_proto_options(request: &CodeGeneratorRequest) -> impl Iterator<Item = PyPackageConfig> {
    request.proto_file.iter().map(|file| {
        let opts = py_package::exts::py_package_opts.get(&file.options);
        if let Some(opt) = &opts {
            log::info!("Found py_package options in file: {}", file.name());
            log::info!("Options: {:?}", opt);
        };
        PyPackageConfig {
            opts,
            file_descriptor: file,
        }
    })
}

fn generate_files<'a>(opts: impl Iterator<Item = PyPackageConfig<'a>>) -> Vec<File> {
    let mut output_files: HashMap<String, File> = HashMap::new();
    opts.flat_map(|config| {
        // protoc_gen_py_pkg::generate_py_init_files(file_descriptor, opts)
        let file_descriptor = config.file_descriptor;
        let opts = config.opts;
        let configs = create_py_init_configs(file_descriptor, &opts, load_python_import_file(&opts));
        generate_py_init_files(configs)
    })
    .for_each(|file| {
        if let Some(file_name) = file.name.as_ref() {
            log::info!("Generated file: {}", file_name);
            output_files.insert(file_name.clone(), file);
        } else {
            log::warn!("Generated file with no name, skipping.");
        }
    });

    output_files.into_values().collect()
}

pub fn process_request(request: CodeGeneratorRequest) -> CodeGeneratorResponse {
    let mut response = CodeGeneratorResponse::new();
    response.set_supported_features(CODE_GENERATOR_RESPONSE_FEATURE_PROTO3_OPTIONAL);

    // Extract options from proto files
    let proto_options = extract_proto_options(&request);

    // Generate files based on options
    let files = generate_files(proto_options);

    // Add files to response
    for file in files {
        response.file.push(file);
    }

    response
}

#[cfg(test)]
mod tests {
    use protobuf::descriptor::FileDescriptorProto;

    use super::*;

    #[test]
    fn it_should_generate_py_init_configs() {
        let mut opts = py_package::PyPackageOptions::new();
        opts.enable = true;
        opts.enable_top_level_imports = true;
        let mut file_descriptor = FileDescriptorProto::new();
        file_descriptor.set_name(String::from("example/v1/foo.proto"));
        let mut foo = protobuf::descriptor::DescriptorProto::new();
        foo.set_name(String::from("Foo"));
        file_descriptor.message_type.push(foo);
        let binding = Some(opts);
        let result = create_py_init_configs(
            &file_descriptor,
            &binding,
            vec!["# Generated by protoc-gen-py-pkg\n".to_string()],
        );
        assert_eq!(result.len(), 2);
        assert!(result.contains_key("example"));
        assert!(result.contains_key("example/v1"));
        if let Some(init_config) = result.get("example") {
            assert_eq!(init_config.py_imports.len(), 1);
            assert_eq!(
                init_config.py_imports[0],
                "# Generated by protoc-gen-py-pkg\n"
            );
        }
        if let Some(init_config) = result.get("example/v1") {
            assert_eq!(init_config.py_imports.len(), 1);
            assert_eq!(
                init_config.py_imports[0],
                "# Generated by protoc-gen-py-pkg\n"
            );
        }
    }

    #[test]
    fn it_should_generate_py_init_configs_with_no_opts() {
        let opts: Option<py_package::PyPackageOptions> = None;
        let result = create_py_init_configs(&FileDescriptorProto::new(), &opts, vec![]);
        assert!(result.is_empty());
    }

    #[test]
    fn it_should_generate_py_init_configs_with_no_global_imports() {
        let mut opts = py_package::PyPackageOptions::new();
        opts.enable = true;
        opts.enable_top_level_imports = false;
        let mut file_descriptor = FileDescriptorProto::new();
        file_descriptor.set_name(String::from("example/v1/foo.proto"));
        let mut foo = protobuf::descriptor::DescriptorProto::new();
        foo.set_name(String::from("Foo"));
        file_descriptor.message_type.push(foo);
        let binding = Some(opts);
        let result = create_py_init_configs(
            &file_descriptor,
            &binding,
            vec![
                "# Generated by protoc-gen-py-pkg".to_string(),
                "from foo.example.v1.foo_pb2 import Foo".to_string(),
            ],
        );
        assert_eq!(result.len(), 2);
        assert!(result.contains_key("example"));
        assert!(result.contains_key("example/v1"));
        if let Some(init_config) = result.get("example") {
            assert_eq!(init_config.py_imports.len(), 1);
            assert_eq!(
                init_config.py_imports[0],
                "# Generated by protoc-gen-py-pkg\n"
            );
        }
        if let Some(init_config) = result.get("example/v1") {
            assert_eq!(init_config.py_imports.len(), 1);
            assert_eq!(
                init_config.py_imports[0],
                "# Generated by protoc-gen-py-pkg\n"
            );
        }
    }

    #[test]
    fn it_should_generate_py_init_configs_with_enable_versioned_imports() {
        let mut opts = py_package::PyPackageOptions::new();
        opts.enable_versioned_imports = true;
        let mut expected_content = include_str!("py_top_py_package_versioned_imports.py").to_string();
        expected_content += "\n";
        let expected_lines: Vec<String> = expected_content.lines().map(String::from).collect();
        let result = load_python_import_file(&Some(opts));
        assert_eq!(result, expected_lines);
    }
}
